/*
 * Common base C++ source for codeeval solutions.
 * */
#include <algorithm>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <iterator>
#include <sstream>
#include <string>
#include <tuple>
#include <vector>

void test();
void process_file(char*);
int main(int argc, char ** argv) {
    if( 0 ) {
        test();
    } else {
        process_file(argv[1]);
    }
	return 0;
}

void solve(std::vector<std::string> &schema);

void test() {
    std::vector<std::string> schema {
        "************************* *************************", "*                                   * *           *",
        "* * *** *** ******************* ***** * * * * * ***", "* * *   * *   *   * * *                 * * * *   *",
        "***** * * *** * *** * * *** *** * ***** *** *******", "*     * *   * *     *   * * *   *     * * *       *",
        "*** ******* * ***** *** * * ******* * *** * *** * *", "* *     *     *   *     *     *     * *       * * *",
        "* * *********** * ********* * ******* * *** * *****", "*     * *   * * *     *     * *   *   * *   *     *",
        "* ***** * *** * ***** *** *** * * * ******* ***** *", "* *     *   * * *       * * *   * * * *   *     * *",
        "* * ***** *** *** *** *** * ***** *** *** ***** ***", "*     *   * * *     * *       * *       * *     * *",
        "* * ***** * * * *** * *** ***** *** ***** *** * * *", "* * *           *   * *   *     *     *     * *   *",
        "* ******* ******* * *** ******* *** * * ********* *", "*   *       *     * *   *         * * * *     *   *",
        "*** * * ***** * ***** ******* ******* * * * * * ***", "*     *   *   *         *       * *   * * * * *   *",
        "*** * *** * *** ***** ******* * * * *** *** * *** *", "* * * * * * * *     * * *     *       *   * * * * *",
        "* * *** * * * *** *** * * ********* ***** * * * * *", "* * *   * * *     *   * *   *     *   *     * * * *",
        "* * * *** ******* ***** * ******* *** * *** *** * *", "* * *     *   *   *     * *     * * * *   *   * * *",
        "* ***** * * * *** * ***** ***** * * * ***** * * * *", "* *     * * * *     * *     *           * * *   * *",
        "* ***** * *** * ***** *********** ******* * * * * *", "*     * * * *             *   *     * * *   * * * *",
        "* * * *** * *** * ***** ***** ******* * *** * * * *", "* * *   * * *   *     * *             *     * * * *",
        "* ***** * * *********** ******* *** * ******* * * *", "* *     *   *   *     * *   *   * * *       * *   *",
        "* * * ********* * ***** * *** *** *** * ***** * ***", "* * *       *           *   * * *   * *   *   *   *",
        "* ******* ***** ******* * *** * * *** *** * *******", "*   *   *   *   *   *     *         * * * * * * * *",
        "* ***** * *** ***** * ******* * ***** * *** * * * *", "*     *           *     *     * * *   *   *     * *",
        "*** *** ********************* *** *** *** *** * * *", "*   *   *     *               * * *   *       *   *",
        "*** *** * ***** * ******* *** * * *** * *** ***** *", "*       *       *   *   * * *   *     *   * *   * *",
        "*** ***** ***** *** *** *** ***** * * *** *** * * *", "*       *   *   * * *       *   * * *   * *   *   *",
        "*** *** * ***** * ***** *** *** *** *** ******* ***", "*   *     *   *   *     * * * *     * * *     *   *",
        "* ***** *** ***** ******* * * *** *** * *** ***** *", "*   *                 *           *         *     *",
        "************************* *************************",
    };
    std::vector<std::string> expected_result {
        "*************************+*************************", "*                        +++++++    * *           *",
        "* * *** *** *******************+***** * * * * * ***", "* * *   * *   *   * * *    +++++        * * * *   *",
        "***** * * *** * *** * * ***+*** * ***** *** *******", "*     * *   * *     *   * *+*   *     * * *       *",
        "*** ******* * ***** *** * *+******* * *** * *** * *", "* *     *     *   *     *  +  *     * *       * * *",
        "* * *********** * *********+* ******* * *** * *****", "*     * *   * * *     *  +++* *   *   * *   *     *",
        "* ***** * *** * ***** ***+*** * * * ******* ***** *", "* *     *   * * *       *+* *   * * * *   *     * *",
        "* * ***** *** *** *** ***+* ***** *** *** ***** ***", "*     *   * * *     * *  +    * *       * *     * *",
        "* * ***** * * * *** * ***+***** *** ***** *** * * *", "* * *           *   * *+++*     *     *     * *   *",
        "* ******* ******* * ***+******* *** * * ********* *", "*   *       *     * *+++*         * * * *     *   *",
        "*** * * ***** * *****+******* ******* * * * * * ***", "*     *   *   *+++++++  *       * *   * * * * *   *",
        "*** * *** * ***+***** ******* * * * *** *** * *** *", "* * * * * * * *+++  * * *     *       *   * * * * *",
        "* * *** * * * ***+*** * * ********* ***** * * * * *", "* * *   * * *    +*   * *   *     *   *     * * * *",
        "* * * *** *******+***** * ******* *** * *** *** * *", "* * *     *   *  +*     * *     * * * *   *   * * *",
        "* ***** * * * ***+* ***** ***** * * * ***** * * * *", "* *     * * * *+++  * *     *           * * *   * *",
        "* ***** * *** *+***** *********** ******* * * * * *", "*     * * * *  +++++++++  *   *     * * *   * * * *",
        "* * * *** * *** * *****+***** ******* * *** * * * *", "* * *   * * *   *     *+*      +++++++*     * * * *",
        "* ***** * * ***********+*******+*** *+******* * * *", "* *     *   *   *     *+*   *+++* * *+      * *   *",
        "* * * ********* * *****+* ***+*** ***+* ***** * ***", "* * *       *  +++++++++*   *+* *   *+*   *   *   *",
        "* ******* *****+******* * ***+* * ***+*** * *******", "*   *   *   *+++*   *     *  +      *+* * * * * * *",
        "* ***** * ***+***** * *******+* *****+* *** * * * *", "*     *+++++++    *     *    +* * *  +*   *     * *",
        "*** ***+*********************+*** ***+*** *** * * *", "*   *  +*     *+++++++++++++++* * *  +*       *   *",
        "*** ***+* *****+* ******* *** * * ***+* *** ***** *", "*  +++++*+++++++*   *   * * *   *  +++*   * *   * *",
        "***+*****+***** *** *** *** ***** *+* *** *** * * *", "*  +++++*+  *   * * *       *   * *+*   * *   *   *",
        "*** ***+*+***** * ***** *** *** ***+*** ******* ***", "*   *  +++*   *   *     * * * *  +++* * *     *   *",
        "* ***** *** ***** ******* * * ***+*** * *** ***** *", "*   *                 *  +++++++++*         *     *",
        "*************************+*************************",
    };

    solve(schema);

    // std::endl for flush?
    for(auto &s : schema) {
        std::cout << s << "\n";
    }
    if(0) {
        for(auto &s : expected_result) {
            std::cout << s << "\n";
        }
    }
}

void process_file(char* path) {
    std::vector<std::string> schema;
    schema.reserve(101);

	std::ifstream stream(path);
	for(std::string line; std::getline(stream, line); ) {
		schema.push_back(line);
	}

    solve(schema);

    for(auto &s : schema) {
        std::cout << s << "\n";
    }
}

void solve(std::vector<std::string> &schema) {
    std::vector<std::vector<int>> dist;
    const int MAXD = std::numeric_limits<int>::max();

    // fill distance matrix with initial values
    dist.reserve(schema.size());
    for(auto& s : schema) {
        std::vector<int> d;
        d.reserve(s.length());

        for(auto c : s) {
            // -1 - blocked cell, MAXD - passable, but not yet visited
            d.push_back((' ' == c) ? MAXD : -1);
        }

        dist.push_back(d);
    }

    std::vector<std::pair<int,int>> stack;
    stack.push_back({ schema.front().find(' '), 0 });
    dist[0][stack.back().first] = 1;

    while(!stack.empty()) {
        if(stack.size() > 1) {
            std::sort(std::begin(stack), std::end(stack), [&dist](const std::pair<int,int> &a, const std::pair<int,int> &b) {
                return dist[b.second][b.first] < dist[a.second][a.first];
            });
        }
        const int cx = stack.back().first;
        const int cy = stack.back().second;
        int &cd = dist[cy][cx];
        stack.pop_back();
    
        int dx = 0, dy = -1;
        for(int i = 0; i < 4; ++i) {
            std::tie(dx, dy) = std::make_tuple (dy, -dx);
            const int x = cx + dx;
            const int y = cy + dy;
            if( x < 0 || y < 0 || y >= dist.size()) {
                continue;
            }
            auto& l = dist[y];
            if( x >= l.size() ) {
                continue;
            }
            auto& lx = l[x];
            if( -1 == lx) {
                continue;
            }
            if(MAXD == lx) {
                    stack.push_back({ x, y });
            }
            if(lx < cd) {
                cd = lx + 1;
            } else if (lx > cd) {
                lx = cd + 1;
            }
        }
    }

    int x = schema.back().find(' ');
    int y = schema.size() - 1;
    schema[y][x] = '+';
    do {
        int dx = 0, dy = -1;
        int mx, my, md = MAXD;
        for(int i = 0; i < 4; ++i) {
            std::tie(dx, dy) = std::make_tuple (dy, -dx);
            int nx = x + dx;
            int ny = y + dy;
            if(nx < 0 || ny < 0 || ny >= dist.size() || nx >= dist[ny].size()) {
                continue;
            }
            const int nd = dist[ny][nx];
            if(nd == -1) {
                continue;
            }
            if(md >= nd) {
                md = nd;
                mx = nx;
                my = ny;
            }
        }
        x = mx;
        y = my;
        schema[y][x] = '+';//0' + (md%10);
    } while(0 != y);
}

